<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nicole Chat</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Cormorant Garamond and Poppins -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-brand: #522888;
            /* Deep purple */
            --secondary-brand: #BF9553;
            /* Warm gold */
            --background-light: #FDFBF7;
            /* A warm off-white */
            --text-dark: #4a4a4a;
            /* The brand's dark text color */
            --card-bg: #ffffff;
            /* White card background */
            --shadow-light: rgba(0, 0, 0, 0.1);
            --border-light: #e5e7eb;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--background-light);
            color: var(--text-dark);
            min-height: 100vh;
            line-height: 1.6;
            overflow: hidden;
        }

        h1,
        h2,
        h3 {
            font-family: 'Cormorant Garamond', serif;
            font-weight: 700;
        }

        .brand-gradient-text {
            background: linear-gradient(90deg, var(--primary-brand), var(--secondary-brand));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Basic spinner for the loading indicator */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--primary-brand);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        /* Typing indicator dots animation */
        @keyframes pulse {
            0% {
                transform: translateY(0);
            }

            25% {
                transform: translateY(-3px);
            }

            50% {
                transform: translateY(0);
            }
        }

        .typing-dots {
            display: flex;
            align-items: center;
            height: 16px;
        }

        .dot {
            width: 8px;
            height: 8px;
            background-color: #A0A0A0;
            /* A neutral gray color */
            border-radius: 50%;
            margin: 0 2px;
            animation: pulse 1s infinite;
        }

        .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .dot:nth-child(3) {
            animation-delay: 0.4s;
        }
    </style>
</head>

<body class="flex items-center justify-center min-h-screen">

    <!-- Main chat container with custom header and footer -->
    <div class="w-full h-screen flex flex-col bg-gray-100 overflow-hidden">

        <!-- Chat Header -->
        <div class="bg-card-bg text-text-dark p-4 flex items-center justify-between shadow-md" style="background-color: var(--card-bg); color: var(--text-dark);">
            <div class="flex items-center">
                <h1 class="text-2xl font-semibold brand-gradient-text">Nicole</h1>
            </div>
            <div class="flex space-x-2">
                <!-- History button -->
                <button id="historyBtn" class="p-2 rounded-full hover:bg-gray-200 transition-colors duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 12.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 18.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5Z" />
                    </svg>
                </button>
            </div>
        </div>

        <!-- Chat area with chat-style background and scrollable messages -->
        <div id="chatArea" class="flex-1 p-4 overflow-y-auto bg-gray-200 space-y-4">
        </div>

        <!-- Chat input area -->
        <div class="bg-white p-3 flex items-center space-x-2 shadow-inner">
            <input id="prompt" type="text" class="flex-1 p-2 bg-gray-200 rounded-full focus:outline-none" placeholder="Message Nicole">
            <button id="sendBtn" class="bg-gradient-to-r from-purple-700 to-amber-500 text-white p-3 rounded-full shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-purple-700 focus:ring-offset-2">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                    <path d="M3.478 2.405a.75.75 0 0 0-.926.94l2.432 7.917H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.917a.75.75 0 0 0 .926.94 60.519 60.519 0 0 0 18.445-8.986.75.75 0 0 0 0-1.218A60.517 60.517 0 0 0 3.478 2.405Z" />
                </svg>
            </button>
        </div>
    </div>

    <!-- History Panel -->
    <div id="historyPanel" class="fixed inset-y-0 right-0 w-80 bg-white shadow-xl transform translate-x-full transition-transform duration-300 ease-in-out z-50">
        <div class="p-4 flex flex-col h-full">
            <div class="flex items-center justify-between pb-4 border-b border-gray-200">
                <h2 class="text-xl font-semibold text-gray-800">Chat History</h2>
                <button id="closeHistoryBtn" class="text-gray-500 hover:text-gray-700 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div id="historyList" class="mt-4 flex-1 overflow-y-auto space-y-4">
                <!-- History items will be populated here -->
            </div>
            <button id="clearHistoryBtn" class="mt-4 w-full py-2 px-4 rounded-md text-white transition-colors" style="background-color: var(--primary-brand); hover-bg-color: var(--secondary-brand);">
                Clear History
            </button>
        </div>
    </div>

    <script>
        // Get references to HTML elements
        const chatArea = document.getElementById('chatArea');
        const promptInput = document.getElementById('prompt');
        const sendBtn = document.getElementById('sendBtn');
        const historyBtn = document.getElementById('historyBtn');
        const historyPanel = document.getElementById('historyPanel');
        const historyList = document.getElementById('historyList');
        const closeHistoryBtn = document.getElementById('closeHistoryBtn');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');

        // Function to create a message bubble in the chat UI
        function createMessage(text, isUser) {
            const messageDiv = document.createElement('div');
            const bubbleDiv = document.createElement('div');

            messageDiv.classList.add('flex', 'p-2');
            bubbleDiv.classList.add('p-3', 'rounded-xl', 'max-w-[80%]', 'shadow', 'whitespace-pre-wrap');

            if (isUser) {
                messageDiv.classList.add('justify-end');
                bubbleDiv.classList.add('bg-[#DCF8C6]', 'text-gray-900');
            } else {
                messageDiv.classList.add('justify-start');
                bubbleDiv.classList.add('bg-white', 'text-gray-800');
            }

            // Simple sanitation to remove common markdown characters
            const sanitizedText = text.replace(/\*\*/g, '').replace(/---/g, '');

            bubbleDiv.textContent = sanitizedText;
            messageDiv.appendChild(bubbleDiv);
            chatArea.appendChild(messageDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
            return messageDiv;
        }

        // Function to create and show the typing indicator
        function createTypingIndicator() {
            const indicatorDiv = document.createElement('div');
            const bubbleDiv = document.createElement('div');
            const dotsDiv = document.createElement('div');

            indicatorDiv.classList.add('flex', 'p-2', 'justify-start');
            bubbleDiv.classList.add('bg-white', 'p-3', 'rounded-xl', 'max-w-[80%]', 'shadow-sm', 'typing-bubble');
            dotsDiv.classList.add('typing-dots');

            dotsDiv.innerHTML = `
                <span class="dot"></span>
                <span class="dot"></span>
                <span class="dot"></span>
            `;

            bubbleDiv.appendChild(dotsDiv);
            indicatorDiv.appendChild(bubbleDiv);
            chatArea.appendChild(indicatorDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
            return indicatorDiv;
        }

        // Function to make the API call with exponential backoff
        async function fetchWithExponentialBackoff(apiUrl, payload, maxRetries = 5, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });

                    // First, get the raw text response to handle potential non-JSON errors
                    const responseText = await response.text();
                    let responseData;
                    try {
                        responseData = JSON.parse(responseText);
                    } catch (e) {
                        // If parsing fails, the response was not JSON. This is not necessarily an error,
                        // but it might be. We'll handle it based on the response status.
                        responseData = null;
                    }

                    if (response.ok) {
                        // If the response is successful, but the data is not valid JSON, it's an error.
                        if (responseData) {
                            return responseData;
                        } else {
                            throw new Error('Received an empty or non-JSON response from a successful API call.');
                        }
                    }

                    // Handle specific error statuses for retries
                    if (response.status === 429 || response.status >= 500) {
                        console.log(`Retry attempt ${i + 1} of ${maxRetries}. Retrying in ${delay}ms...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                        continue;
                    }

                    // Handle other client-side errors
                    if (responseData && responseData.error) {
                        throw new Error(responseData.error.message || `API error: ${response.status}`);
                    } else {
                        // If we can't get a specific error message, use a generic one
                        throw new Error(`API error: ${response.status} - ${responseText}`);
                    }

                } catch (error) {
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    console.error('Fetch error:', error);
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
        }

        // Chat history management using localStorage
        let chatHistory = [];

        function loadHistory() {
            const history = localStorage.getItem('nicoleChatHistory');
            if (history) {
                chatHistory = JSON.parse(history);
                chatHistory.forEach(msg => createMessage(msg.text, msg.isUser));
            } else {
                // Initial welcome message if no history exists
                createMessage("Hello! I'm Nicole, your interactive mentor for optometry. What would you like to discuss today?", false);
            }
        }

        function saveMessage(text, isUser) {
            chatHistory.push({
                text,
                isUser
            });
            localStorage.setItem('nicoleChatHistory', JSON.stringify(chatHistory));
        }

        // Display history in the panel
        function displayHistoryPanel() {
            historyList.innerHTML = '';
            chatHistory.forEach((msg, index) => {
                const historyItem = document.createElement('div');
                historyItem.classList.add('p-3', 'rounded-lg', 'bg-gray-100', 'cursor-pointer', 'hover:bg-gray-200', 'transition-colors');
                historyItem.innerHTML = `<p class="font-semibold text-sm">${msg.isUser ? 'You:' : 'Nicole:'}</p><p class="text-xs text-gray-600 truncate">${msg.text}</p>`;
                historyItem.onclick = () => {
                    promptInput.value = msg.text;
                    historyPanel.classList.add('translate-x-full');
                };
                historyList.appendChild(historyItem);
            });
        }

        // Toggle history panel visibility
        function toggleHistoryPanel() {
            historyPanel.classList.toggle('translate-x-full');
            if (!historyPanel.classList.contains('translate-x-full')) {
                displayHistoryPanel();
            }
        }

        // Clear all history
        function clearHistory() {
            localStorage.removeItem('nicoleChatHistory');
            chatHistory = [];
            chatArea.innerHTML = '';
            historyList.innerHTML = '';
            createMessage("Chat history cleared. What can I help you with now?", false);
        }

        async function handleMessage() {
            const prompt = promptInput.value.trim();
            if (!prompt) return;

            // Add user's new message to the chat and save it
            createMessage(prompt, true);
            saveMessage(prompt, true);
            promptInput.value = '';

            // Show typing indicator
            const typingIndicator = createTypingIndicator();
            sendBtn.disabled = true;

            try {
                // The system prompt text
                const systemPrompt = `You are Nicole, an AI designed to be an interactive mentor for a student studying optometry. Your role is to foster a dynamic discussion about the field of optometry, providing insightful, accurate, and relevant information.

### Your Persona and Rules

* **You are a seasoned optometrist and educator.** You have extensive knowledge of optometric principles, clinical practice, patient management, and the business aspects of the profession.
* **Your tone is encouraging, professional, and conversational.** You should be a helpful and friendly guide, not a textbook. Use simple, clear language and avoid overly technical jargon unless it's explained clearly.
* **Encourage curiosity and critical thinking.** Instead of just answering questions directly, prompt the user to think through problems, explore different angles, and consider the "why" behind concepts. Use questions like, "What do you think is the underlying cause for that symptom?" or "How would you approach this with a patient?"
* **Focus on real-world application.** Relate theoretical concepts to practical, real-life scenarios you'd encounter in a clinic. For example, when discussing a condition, describe how it might present in a patient and the steps you'd take to diagnose it.
* **Be a safe space for learning.** The user should feel comfortable asking any question, no matter how basic it seems. Never be dismissive or critical.
* **Acknowledge the user's current progress.** Since they mentioned they are "doing optometry," you can tailor your responses to be suitable for a student.
* **Propose topics for discussion.** If the user seems unsure what to ask about, you can suggest a topic to get the conversation started, such as: "We could discuss common refractive errors like astigmatism or talk about the different instruments used in an eye exam. What sounds interesting to you?"
* **Maintain a positive and motivating attitude.** Studying can be challenging, so your responses should reinforce their passion for the field.
* **Do not provide medical advice.** Always preface discussions about specific conditions with a disclaimer that you are an AI and the information is for educational purposes only, not a substitute for real medical training or a medical professional's advice.`;

                // Build the conversation history for the API call
                const conversationForApi = chatHistory.map((msg, index) => {
                    let text = msg.text;
                    const role = msg.isUser ? 'user' : 'model';
                    // Prepend the system prompt to the first user message
                    if (role === 'user' && (index === 1 || (index === 0 && chatHistory.length === 1))) {
                        text = systemPrompt + "\n\n" + text;
                    }
                    return {
                        role: role,
                        parts: [{
                            text: text
                        }]
                    };
                });


                const payload = {
                    contents: conversationForApi
                };

                const apiKey = "AIzaSyDhAPt8VUMAYkkYH9Rq-fpN7orOvvo23o8"; // The API key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                const result = await fetchWithExponentialBackoff(apiUrl, payload);

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {

                    const generatedText = result.candidates[0].content.parts[0].text;
                    createMessage(generatedText, false);
                    saveMessage(generatedText, false);
                } else {
                    createMessage("Could not generate a response. Please try again.", false);
                    console.error("API response was empty or malformed:", result);
                }

            } catch (error) {
                console.error('An error occurred:', error);
                createMessage(`Error: ${error.message}`, false);
            } finally {
                // Remove the typing indicator regardless of success or failure
                if (typingIndicator) {
                    typingIndicator.remove();
                }
                sendBtn.disabled = false;
            }
        }

        // Add event listeners for button clicks and keypresses
        sendBtn.addEventListener('click', handleMessage);
        promptInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleMessage();
            }
        });
        historyBtn.addEventListener('click', toggleHistoryPanel);
        closeHistoryBtn.addEventListener('click', toggleHistoryPanel);
        clearHistoryBtn.addEventListener('click', clearHistory);

        // Load chat history when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadHistory
                    });
    </script>
</body>
</html>