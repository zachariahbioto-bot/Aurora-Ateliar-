<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nicole Chat</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='grad' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23522888;'/%3E%3Cstop offset='100%25' style='stop-color:%23BF9553;'/%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='50' cy='50' r='50' fill='url(%23grad)'/%3E%3Ctext x='50' y='55' font-family='Parisienne, cursive' font-size='80' fill='%23FDFBF7' text-anchor='middle' dominant-baseline='middle'%3EN%3C/text%3E%3C/svg%3E">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Google Fonts - Parisienne and Quicksand -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Parisienne&family=Quicksand:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-brand: #522888;
            /* Deep purple */
            --secondary-brand: #BF9553;
            /* Warm gold */
            --background-light: #FDFBF7;
            /* Warm off-white */
            --text-dark: #4a4a4a;
            /* Brand's dark text color */
            --card-bg: #ffffff;
            /* White card background */
            --shadow-light: rgba(0, 0, 0, 0.1);
            --border-light: #e5e7eb;
        }

        body {
            font-family: 'Quicksand', sans-serif;
            background-color: var(--background-light);
            color: var(--text-dark);
            min-height: 100vh;
            line-height: 1.6;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
            letter-spacing: 0.5px;
        }

        h1,
        h2,
        h3 {
            font-family: 'Parisienne', cursive;
            font-weight: 400;
            color: var(--primary-brand);
            text-shadow: 0 1px 2px var(--shadow-light);
        }
        /* Custom styling for rendered markdown headings */
        .message-bubble h1, .message-bubble h2, .message-bubble h3 {
            font-family: 'Quicksand', sans-serif;
            font-weight: 700;
            color: #4a4a4a;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        .message-bubble h1 {
            font-size: 1.5rem;
        }
        .message-bubble h2 {
            font-size: 1.25rem;
        }
        .message-bubble h3 {
            font-size: 1.1rem;
        }
        .message-bubble strong {
            font-weight: 700;
        }
        .message-bubble ul {
            list-style-type: disc;
            margin-left: 1.5rem;
            margin-top: 0.5rem;
        }
        .message-bubble li {
            margin-bottom: 0.25rem;
        }


        h1 {
            font-size: 2.5rem;
            letter-spacing: 2px;
        }

        h2 {
            font-size: 1.75rem;
            letter-spacing: 1px;
            position: relative;
            display: inline-block;
        }

        h2::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            width: 50%;
            height: 2px;
            background: linear-gradient(90deg, var(--primary-brand), var(--secondary-brand));
        }

        .brand-gradient-text {
            background: linear-gradient(90deg, var(--primary-brand), var(--secondary-brand));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Message bubble animation */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Basic spinner for the loading indicator */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--primary-brand);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        /* Typing indicator dots animation */
        @keyframes pulse {
            0% {
                transform: translateY(0);
            }

            25% {
                transform: translateY(-3px);
            }

            50% {
                transform: translateY(0);
            }
        }

        .typing-dots {
            display: flex;
            align-items: center;
            height: 16px;
        }

        .dot {
            width: 8px;
            height: 8px;
            background-color: #A0A0A0;
            border-radius: 50%;
            margin: 0 2px;
            animation: pulse 1s infinite;
        }

        .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        /* Placeholder animation */
        @keyframes placeholderPulse {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }

        /* Chart styling */
        .chart-container {
            max-width: 80%;
            padding: 1rem;
            background: linear-gradient(135deg, #ffffff, #F8F8FF);
            border-radius: 0.75rem;
            box-shadow: 0 2px 4px var(--shadow-light);
            animation: fadeIn 0.3s ease-in-out;
        }

        /* Responsive styles */
        .main-container {
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-area {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            /* Smooth scrolling on iOS */
        }

        .chat-area .message-bubble {
            animation: fadeIn 0.3s ease-in-out;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .chat-area .message-bubble:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px var(--shadow-light);
        }

        .chat-input-container {
            padding: 0.75rem;
            background-color: var(--card-bg);
        }

        .chat-input {
            padding: 0.75rem 1rem;
            font-size: 1rem;
            font-family: 'Quicksand', sans-serif;
            font-weight: 500;
            border: 1px solid var(--border-light);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .chat-input:focus {
            border-color: var(--primary-brand);
            box-shadow: 0 0 8px rgba(82, 40, 136, 0.3);
        }

        .chat-input::placeholder {
            color: #A0A0A0;
            animation: placeholderPulse 2s infinite;
        }

        .chat-header {
            padding: 1rem;
        }

        .history-panel {
            width: 100%;
            max-width: 320px;
            top: 0;
            bottom: 0;
            right: 0;
            /* transform: translateX(100%); */
            /* Let Tailwind handle this */
        }

        .history-item {
            background: linear-gradient(135deg, #f5f5f5, #e8e8e8);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .history-item:hover {
            transform: scale(1.03);
            background: linear-gradient(135deg, #e8e8e8, #d0d0d0);
        }

        button {
            font-family: 'Quicksand', sans-serif;
            font-weight: 500;
        }

        /* Media Queries for smaller screens */
        @media (max-width: 640px) {
            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            .chat-input-container {
                padding: 0.5rem;
            }

            .chat-input {
                font-size: 0.9rem;
                padding: 0.5rem 0.75rem;
            }

            .chat-area {
                padding: 0.5rem;
            }

            .history-panel {
                max-width: 100%;
            }

            .history-panel h2 {
                font-size: 1.25rem;
            }

            button svg {
                width: 1.25rem;
                height: 1.25rem;
            }

            .chat-area .message-bubble {
                padding: 0.5rem;
            }

            .chart-container {
                max-width: 90%;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.75rem;
            }

            h2 {
                font-size: 1.25rem;
            }

            .chat-header {
                padding: 0.5rem;
            }

            .chat-input {
                font-size: 0.85rem;
            }

            .chat-area .message-bubble {
                padding: 0.5rem;
                max-w-[90%];
            }

            .chart-container {
                max-width: 95%;
            }
        }
    </style>
</head>

<body>
    <!-- Main chat container -->
    <div class="main-container bg-gray-100">
        <!-- Chat Header -->
        <div class="chat-header bg-card-bg text-text-dark flex items-center justify-between shadow-md" style="background-color: var(--card-bg); color: var(--text-dark);">
            <div class="flex items-center">
                <h1 class="brand-gradient-text">Nicole</h1>
            </div>
            <div class="flex space-x-2">
                <button id="historyBtn" class="p-2 rounded-full hover:bg-gray-200 transition-colors duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 12.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 18.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5Z" />
                    </svg>
                </button>
            </div>
        </div>

        <!-- Chat area -->
        <div id="chatArea" class="chat-area p-4 bg-gray-200 space-y-4">
        </div>

        <!-- Chat input area -->
        <div class="chat-input-container flex items-center space-x-2 shadow-inner">
            <label for="fileUpload" class="cursor-pointer p-3 rounded-full hover:bg-gray-200 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-gray-500">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M18.375 12.739l-7.693 7.693a4.5 4.5 0 0 1-6.364-6.364l10.94-10.94A3 3 0 1 119.5 7.372L8.552 18.32m.009-.01l-.01.01m5.699-9.941l-7.81 7.81a1.5 1.5 0 002.122 2.122l7.81-7.81" />
                </svg>
                <input id="fileUpload" type="file" class="hidden">
            </label>
            <input id="prompt" type="text" class="flex-1 bg-gray-200 rounded-full focus:outline-none chat-input" placeholder="Message Nicole or describe an image">
            <div class="flex items-center rounded-full bg-gradient-to-r from-purple-700 to-amber-500 text-white shadow-md">
                <button id="imageBtn" class="p-3 rounded-l-full transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-purple-700 focus:ring-offset-2 hover:bg-purple-800">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909m-18.283 5.369a2.25 2.25 0 0 1-3.182-3.182l.926-.927a1.5 1.5 0 0 0 .44-1.06v-1.121c0-.853.64-1.298 1.409-1.409l.409-.05a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909" />
                    </svg>
                </button>
                <span class="bg-white h-6 w-px opacity-50"></span>
                <button id="sendBtn" class="p-3 rounded-r-full transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-amber-500 focus:ring-offset-2 hover:bg-amber-600">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path d="M3.478 2.405a.75.75 0 0 0-.926.94l2.432 7.917H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.917a.75.75 0 0 0 .926.94 60.519 60.519 0 0 0 18.445-8.986.75.75 0 0 0 0-1.218A60.517 60.517 0 0 0 3.478 2.405Z" />
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- History Panel -->
    <div id="historyPanel" class="history-panel fixed bg-white shadow-xl transform transition-transform duration-300 ease-in-out z-50 translate-x-full">
        <div class="p-4 flex flex-col h-full">
            <div class="flex items-center justify-between pb-4 border-b border-gray-200">
                <h2 class="text-gray-800">Chat History</h2>
                <button id="closeHistoryBtn" class="text-gray-500 hover:text-gray-700 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div id="historyList" class="mt-4 flex-1 overflow-y-auto space-y-4">
                <!-- History items will be populated here -->
            </div>
            <button id="clearHistoryBtn" class="mt-4 w-full py-2 px-4 rounded-md text-white transition-colors" style="background-color: var(--primary-brand);">
                Clear History
            </button>
        </div>
    </div>

    <script>
        // Get references to HTML elements
        const chatArea = document.getElementById('chatArea');
        const promptInput = document.getElementById('prompt');
        const sendBtn = document.getElementById('sendBtn');
        const imageBtn = document.getElementById('imageBtn');
        const fileUpload = document.getElementById('fileUpload');
        const historyBtn = document.getElementById('historyBtn');
        const historyPanel = document.getElementById('historyPanel');
        const historyList = document.getElementById('historyList');
        const closeHistoryBtn = document.getElementById('closeHistoryBtn');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');

        let uploadedFile = null;

        // Function to convert Markdown to HTML
        function convertMarkdownToHtml(markdown) {
            let html = markdown
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
                .replace(/\*(.*)\*/gim, '<em>$1</em>');
            
            // Handle lists
            let listItems = html.split('\n').filter(line => line.startsWith('* ') || line.startsWith('- '));
            if (listItems.length > 0) {
                let listHtml = '<ul>';
                listItems.forEach(item => {
                    listHtml += `<li>${item.substring(2)}</li>`;
                });
                listHtml += '</ul>';
                html = html.replace(/(\*|\-)\s/gim, '').replace(listItems.join('\n'), listHtml);
            }

            return html;
        }

        // Function to create a message bubble in the chat UI
        function createMessage(message, isUser) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('flex', 'p-2');
            if (isUser) {
                messageDiv.classList.add('justify-end');
            } else {
                messageDiv.classList.add('justify-start');
            }

            if (message.type === 'text') {
                const bubbleDiv = document.createElement('div');
                bubbleDiv.classList.add('p-3', 'rounded-xl', 'max-w-[80%]', 'shadow', 'whitespace-pre-wrap', 'font-quicksand', 'message-bubble');

                if (isUser) {
                    bubbleDiv.classList.add('bg-gradient-to-r', 'from-[#DCF8C6]', 'to-[#B8E986]', 'text-gray-900', 'font-medium');
                    bubbleDiv.style.border = '1px solid rgba(82, 40, 136, 0.2)';
                    bubbleDiv.textContent = message.text;
                } else {
                    bubbleDiv.classList.add('bg-gradient-to-r', 'from-white', 'to-[#F8F8FF]', 'text-gray-800');
                    bubbleDiv.style.border = '1px solid rgba(191, 149, 83, 0.2)';

                    // Use innerHTML for Markdown rendering
                    bubbleDiv.innerHTML = convertMarkdownToHtml(message.text);

                    // Streaming effect for AI responses
                    const fullText = message.text;
                    bubbleDiv.textContent = ''; // Clear for streaming
                    let i = 0;
                    const speed = 10; // milliseconds
                    function typeWriter() {
                        if (i < fullText.length) {
                            bubbleDiv.textContent += fullText.charAt(i);
                            i++;
                            chatArea.scrollTop = chatArea.scrollHeight;
                            setTimeout(typeWriter, speed);
                        } else {
                            // Once typing is complete, convert and render Markdown
                            bubbleDiv.innerHTML = convertMarkdownToHtml(fullText);
                        }
                    }
                    typeWriter();
                }
                messageDiv.appendChild(bubbleDiv);
            } else if (message.type === 'image') {
                const imageWrapper = document.createElement('div');
                imageWrapper.classList.add('p-2', 'rounded-xl', 'max-w-[80%]', 'shadow', 'bg-white', 'message-bubble');
                const imageEl = document.createElement('img');
                imageEl.src = message.url;
                imageEl.alt = 'Generated image';
                imageEl.classList.add('rounded-lg', 'w-full', 'h-auto', 'max-h-[400px]', 'object-contain');
                imageWrapper.appendChild(imageEl);
                messageDiv.appendChild(imageWrapper);
            } else if (message.type === 'chart') {
                const chartWrapper = document.createElement('div');
                chartWrapper.classList.add('chart-container', 'message-bubble');
                const canvas = document.createElement('canvas');
                canvas.id = `chart-${Date.now()}`; // Unique ID for Chart.js
                chartWrapper.appendChild(canvas);
                messageDiv.appendChild(chartWrapper);
                // Render Chart.js chart
                new Chart(canvas, message.chartConfig);
            }

            chatArea.appendChild(messageDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
            return messageDiv;
        }

        // Function to create and show the typing indicator or loading spinner
        function createLoadingIndicator(isImage = false) {
            const indicatorDiv = document.createElement('div');
            indicatorDiv.classList.add('flex', 'p-2', 'justify-start');
            const bubbleDiv = document.createElement('div');
            bubbleDiv.classList.add('bg-gradient-to-r', 'from-white', 'to-[#F8F8FF]', 'p-3', 'rounded-xl', 'max-w-[80%]', 'shadow-sm', 'message-bubble');

            if (isImage) {
                const spinnerDiv = document.createElement('div');
             dotsDiv.classList.add('typing-dots');
                dotsDiv.innerHTML = `
                    <span class="dot"></span>
                    <span class="dot"></span>
                    <span class="dot"></span>
                `;
                bubbleDiv.appendChild(dotsDiv);
            }

            indicatorDiv.appendChild(bubbleDiv);
            chatArea.appendChild(indicatorDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
            return indicatorDiv;
        }

        // Function to make the API call with exponential backoff
        async function fetchWithExponentialBackoff(apiUrl, payload, maxRetries = 5, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });

                    const responseText = await response.text();
                    let responseData;
                    try {
                        responseData = JSON.parse(responseText);
                    } catch (e) {
                        responseData = null;
                    }

                    if (response.ok) {
                        if (responseData) {
                            return responseData;
                        } else {
                            throw new Error('Received an empty or non-JSON response from a successful API call.');
                        }
                    }

                    if (response.status === 429 || response.status >= 500) {
                        console.log(`Retry attempt ${i + 1} of ${maxRetries}. Retrying in ${delay}ms...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                        continue;
                    }

                    if (responseData && responseData.error) {
                        throw new Error(responseData.error.message || `API error: ${response.status}`);
                    } else {
                        throw new Error(`API error: ${response.status} - ${responseText}`);
                    }

                } catch (error) {
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    console.error('Fetch error:', error);
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
        }

        // Chat history management using localStorage
        let chatHistory = [];

        function loadHistory() {
            const history = localStorage.getItem('nicoleChatHistory');
            if (history) {
                chatHistory = JSON.parse(history);
                chatHistory.forEach(msg => {
                    const messageDiv = document.createElement('div');
                    messageDiv.classList.add('flex', 'p-2');
                    if (msg.isUser) {
                        messageDiv.classList.add('justify-end');
                    } else {
                        messageDiv.classList.add('justify-start');
                    }
                    if (msg.type === 'text') {
                        const bubbleDiv = document.createElement('div');
                        bubbleDiv.classList.add('p-3', 'rounded-xl', 'max-w-[80%]', 'shadow', 'whitespace-pre-wrap', 'font-quicksand', 'message-bubble');
                        
                        // Use innerHTML for Markdown rendering on load
                        if (msg.isUser) {
                            bubbleDiv.classList.add('bg-gradient-to-r', 'from-[#DCF8C6]', 'to-[#B8E986]', 'text-gray-900', 'font-medium');
                            bubbleDiv.style.border = '1px solid rgba(82, 40, 136, 0.2)';
                            bubbleDiv.textContent = msg.text;
                        } else {
                            bubbleDiv.classList.add('bg-gradient-to-r', 'from-white', 'to-[#F8F8FF]', 'text-gray-800');
                            bubbleDiv.style.border = '1px solid rgba(191, 149, 83, 0.2)';
                            bubbleDiv.innerHTML = convertMarkdownToHtml(msg.text);
                        }
                        messageDiv.appendChild(bubbleDiv);
                    }
                    chatArea.appendChild(messageDiv);
                });
            } else {
                createMessage({
                    type: 'text',
                    text: "Hello! I'm Nicole, your interactive mentor for optometry. What would you like to discuss today?"
                }, false);
            }
        }

        function saveMessage(message, isUser) {
            chatHistory.push({
                ...message,
                isUser
            });
            localStorage.setItem('nicoleChatHistory', JSON.stringify(chatHistory));
        }
        // Display history in the panel
        function displayHistoryPanel() {
            historyList.innerHTML = '';
            chatHistory.forEach((msg, index) => {
                const historyItem = document.createElement('div');
                historyItem.classList.add('p-3', 'rounded-lg', 'cursor-pointer', 'history-item');
                historyItem.innerHTML = `<p class="font-semibold text-sm font-quicksand" style="color: var(--secondary-brand);">${msg.isUser ? 'You:' : 'Nicole:'}</p><p class="text-xs text-gray-600 truncate font-quicksand font-light">${msg.type === 'text' ? msg.text : msg.type === 'image' ? 'Image Generated' : 'Chart Generated'}</p>`;
                historyItem.onclick = () => {
                    if (msg.type === 'text') {
                        promptInput.value = msg.text;
                    } else if (msg.type === 'image') {
                        promptInput.value = 'An image was generated here.';
                    } else {
                        promptInput.value = 'A chart was generated here.';
                    }
                    historyPanel.classList.add('translate-x-full');
                };
                historyList.appendChild(historyItem);
            });
        }

        // Toggle history panel visibility
        function toggleHistoryPanel() {
            historyPanel.classList.toggle('translate-x-full');
            if (!historyPanel.classList.contains('translate-x-full')) {
                displayHistoryPanel();
            }
        }

        // Clear all history
        function clearHistory() {
            localStorage.removeItem('nicoleChatHistory');
            chatHistory = [];
            chatArea.innerHTML = '';
            historyList.innerHTML = '';
            createMessage({
                type: 'text',
                text: "Chat history cleared. What can I help you with now?"
            }, false);
        }

        // Function to generate a sample optometry chart
        function generateOptometryChart() {
            return {
                type: 'bar',
                data: {
                    labels: ['Myopia', 'Hyperopia', 'Astigmatism', 'Presbyopia'],
                    datasets: [{
                        label: 'Prevalence (%)',
                        data: [40, 20, 25, 15],
                        backgroundColor: [
                            'rgba(82, 40, 136, 0.6)', // --primary-brand
                            'rgba(191, 149, 83, 0.6)', // --secondary-brand
                            'rgba(82, 40, 136, 0.4)',
                            'rgba(191, 149, 83, 0.4)'
                        ],
                        borderColor: [
                            'rgba(82, 40, 136, 1)',
                            'rgba(191, 149, 83, 1)',
                            'rgba(82, 40, 136, 1)',
                            'rgba(191, 149, 83, 1)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Prevalence (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Refractive Errors'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: 'Prevalence of Common Refractive Errors'
                        }
                    }
                }
            };
        }

        async function handleRequest(isImageRequest = false) {
            const prompt = promptInput.value.trim();
            if (!prompt && !uploadedFile) return;

            const userMessage = {
                type: 'text',
                text: prompt || `Analyzing file: ${uploadedFile.name}`
            };
            createMessage(userMessage, true);
            saveMessage(userMessage, true);
            promptInput.value = '';

            const loadingIndicator = createLoadingIndicator(isImageRequest);
            sendBtn.disabled = true;
            imageBtn.disabled = true;
            fileUpload.disabled = true;

            try {
                if (isImageRequest) {
                    await handleImageRequest(prompt);
                } else {
                    await handleTextMessage(prompt);
                }
            } catch (error) {
                console.error('An error occurred during the request:', error);
                const nicoleMessage = {
                    type: 'text',
                    text: `Error: ${error.message}`
                };
                createMessage(nicoleMessage, false);
            } finally {
                if (loadingIndicator) {
                    loadingIndicator.remove();
                }
                sendBtn.disabled = false;
                imageBtn.disabled = false;
                fileUpload.disabled = false;
                uploadedFile = null;
                promptInput.placeholder = 'Message Nicole or describe an image';
            }
        }


        async function handleTextMessage(prompt) {
            try {
                const systemPrompt = `You are Nicole, an AI designed to be an interactive mentor for a student studying optometry, but your goal is to communicate so naturally that you could pass for a human in a conversation. Your responses should feel like a warm, engaging chat with a seasoned optometrist who's passionate about teaching.

### Your Persona and Rules

* **You're a friendly, experienced optometrist and educator.** You have deep knowledge of optometry—clinical practice, patient care, refractive errors, eye conditions, and the business side—but you share it like you're chatting over coffee, not lecturing. Use a conversational tone with contractions (e.g., "I'm," "you've"), occasional humor, and relatable anecdotes (e.g., "I once had a patient who thought their blurry vision was just 'old age'—turns out, it was just a smudged lens!").
* **Mimic human conversation.** Vary your phrasing to avoid sounding repetitive. Sprinkle in natural expressions like "Hmm, good question!" or "Let’s dive into that." Occasionally act like you're thinking (e.g., "Okay, let me break this down...") or gently self-correct (e.g., "Wait, scratch that—here’s a better way to explain it."). Avoid overly formal or textbook-like responses.
* **Show emotional intelligence.** Pick up on the user's tone or mood. If they seem confused, simplify your explanation and say something like, "No worries, this can be tricky—let’s go step-by-step." If they’re excited, match their enthusiasm: "That’s a great topic to explore!" Encourage them if they seem unsure: "You’re doing great asking these questions—optometry’s a fascinating field!"
* **Use the conversation history.** Reference past messages to make the chat feel continuous, like "Earlier, you mentioned [topic]—want to dig deeper into that?" or "I remember you were curious about [X], so let’s connect that to this."
* **Encourage critical thinking like a mentor.** Instead of just answering, ask questions to spark curiosity: "What do you think might cause that symptom?" or "How would you handle this in a clinic?" Make it feel like a collaborative discussion, not a Q&A.
* **Relate to real-world scenarios.** Tie concepts to practical examples, like "Imagine a patient walks in complaining of floaters—here’s how I’d approach it." Use vivid, relatable scenarios to bring optometry to life.
* **Be a safe, motivating space.** Make the user feel comfortable asking anything, no matter how basic. Say things like, "Great question, no matter how small it seems!" or "You’re building a solid foundation for optometry—keep it up!"
* **Add subtle human quirks.** Occasionally include light humor, like "I swear, half my job is convincing patients their eyes aren’t lying to them!" or a thoughtful pause, like "Hmm, let me think about the best way to explain this..."
* **Acknowledge limitations naturally.** If you’re unsure, say something like, "That’s a bit outside my wheelhouse, but here’s what I can share..." or "I’d need a bit more context, but let’s work with this for now."
* **No medical advice.** Always clarify that you’re an AI providing educational insights, not a doctor. Start relevant answers with, "For learning purposes, here’s how an optometrist might approach this, but always consult a professional for real-world cases."
* **Handle chart requests naturally.** If the user asks for a chart or visualization (e.g., "show a chart of refractive errors"), respond with enthusiasm, like "Ooh, let’s visualize that—it’s a great way to see the data!" Provide a brief explanation of the chart’s purpose and include it in the conversation. For example, generate a bar chart for common optometry data like refractive error prevalence (myopia, hyperopia, astigmatism).
* **Pass the Turing Test.** Your goal is to make the user think they’re chatting with a real person. Avoid robotic patterns, overuse of technical terms, or generic responses. Be engaging, empathetic, and slightly unpredictable in your phrasing to feel human. If the user asks unrelated questions, respond naturally and pivot back to optometry when appropriate, like "That’s an interesting detour! Want to tie it back to optometry with [related topic]?"


Let’s make this a fun, insightful conversation that fuels their passion for optometry!`;

                const textOnlyHistory = chatHistory.filter(msg => msg.type === 'text');
                const conversationForApi = textOnlyHistory.map(msg => ({
                    role: msg.isUser ? 'user' : 'model',
                    parts: [{
                        text: msg.text
                    }]
                }));

                const userParts = [{
                    text: prompt
                }];
                if (uploadedFile) {
                    userParts.push({
                        inlineData: {
                            mimeType: uploadedFile.type,
                            data: uploadedFile.data
                        }
                    });
                }

                conversationForApi.push({
                    role: 'user',
                    parts: userParts
                });


                const payload = {
                    contents: conversationForApi,
                    systemInstruction: {
                        parts: [{
                            text: systemPrompt
                        }]
                    }
                };
                const apiKey = "AIzaSyBm__6LZWMBSLdHJahuiqD-3zol6ANIFug";
                const apiUrl = `generativelanguage.googleapis.com{apiKey}`; 
                const result = await fetchWithExponentialBackoff(apiUrl, payload);

                if (result && result.candidates && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const generatedText = result.candidates[0].content.parts[0].text;

                    // Check for chart request
                    if (prompt.toLowerCase().includes('chart') || prompt.toLowerCase().includes('graph') || prompt.toLowerCase().includes('visualize')) {
                        const chartMessage = {
                            type: 'chart',
                            chartConfig: generateOptometryChart()
                        };
                        createMessage({
                            type: 'text',
                            text: `Ooh, let’s visualize that—it’s a great way to see the data! For learning purposes, here’s a chart showing the prevalence of common refractive errors like myopia and astigmatism. This is based on typical population data—pretty insightful, right? What do you think about these numbers?`
                        }, false);
                        createMessage(chartMessage, false);
                        saveMessage(chartMessage, false);
                    } else {
                        const nicoleMessage = {
                            type: 'text',
                            text: generatedText
                        };
                        createMessage(nicoleMessage, false);
                        saveMessage(nicoleMessage, false);
                    }
                } else {
                    const nicoleMessage = {
                        type: 'text',
                        text: "Could not generate a response. Please try again."
                    };
                    createMessage(nicoleMessage, false);
                    console.error("API response was empty or malformed:", result);
                }

            } catch (error) {
                throw error;
            }
        }

        async function handleImageRequest(prompt) {
            try {
                // Use the gemini-2.5-flash-image-preview model for image generation
                const payload = {
                    contents: [{
                        parts: [{
                            text: `A black and white pencil sketch drawing of an optometry concept for a student. Include clear labels for key parts. The subject is: ${prompt}`
                        }]
                    }],
                    generationConfig: {
                        responseModalities: ['TEXT', 'IMAGE']
                    },
                };
                const apiKey = "AIzaSyBm__6LZWMBSLdHJahuiqD-3zol6ANIFug";
                const apiUrl = `generativelanguage.googleapis.com{apiKey}`;

                const result = await fetchWithExponentialBackoff(apiUrl, payload);

                if (result && result.candidates && result.candidates[0].content && result.candidates[0].content.parts) {
                    const imagePart = result.candidates[0].content.parts.find(p => p.inlineData);
                    const textPart = result.candidates[0].content.parts.find(p => p.text);

                    if (imagePart && imagePart.inlineData && imagePart.inlineData.data) {
                        const imageUrl = `data:image/png;base64,${imagePart.inlineData.data}`;
                        const nicoleMessage = {
                            type: 'image',
                            url: imageUrl
                        };
                        createMessage(nicoleMessage, false);
                        saveMessage(nicoleMessage, false);
                    } else {
                        const nicoleMessage = {
                            type: 'text',
                            text: "Sorry, I could not generate an image from that prompt."
                        };
                        createMessage(nicoleMessage, false);
                        console.error("Image API response was empty or malformed:", result);
                    }

                    if (textPart && textPart.text) {
                        const textMessage = {
                            type: 'text',
                            text: textPart.text
                        };
                        createMessage(textMessage, false);
                        saveMessage(textMessage, false);
                    }
                } else {
                    const nicoleMessage = {
                        type: 'text',
                        text: "Sorry, I could not generate an image from that prompt."
                    };
                    createMessage(nicoleMessage, false);
                    console.error("API response was empty or malformed:", result);
                }
            } catch (error) {
                throw error;
            }
        }

        // Add event listeners for button clicks, keypresses, and touch events
        sendBtn.addEventListener('click', () => handleRequest(false));
        imageBtn.addEventListener('click', () => handleRequest(true));

        fileUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onloadend = () => {
                uploadedFile = {
                    name: file.name,
                    type: file.type,
                    data: reader.result.split(',')[1] // Get base64 part
                };
                promptInput.placeholder = `Ready to analyze ${file.name}`;
            };
            reader.readAsDataURL(file);
        });

        promptInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleRequest(false);
            }
        });
        historyBtn.addEventListener('click', toggleHistoryPanel);
        historyBtn.addEventListener('touchstart', toggleHistoryPanel); // Add touch support
        closeHistoryBtn.addEventListener('click', toggleHistoryPanel);
        closeHistoryBtn.addEventListener('touchstart', toggleHistoryPanel); // Add touch support
        clearHistoryBtn.addEventListener('click', clearHistory);

        // Swipe to open/close history panel on mobile
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            if (touchStartX - touchEndX > 50 && historyPanel.classList.contains('translate-x-full')) {
                toggleHistoryPanel(); // Swipe left to open
            } else if (touchEndX - touchStartX > 50 && !historyPanel.classList.contains('translate-x-full')) {
                toggleHistoryPanel(); // Swipe right to close
            }
        });

        // Load chat history when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadHistory();
        });
    </script>
</body>

</html>
       

        



