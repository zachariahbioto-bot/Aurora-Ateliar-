<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nicole Chat</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Google Fonts - Parisienne and Quicksand -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Parisienne&family=Quicksand:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-brand: #522888;
            /* Deep purple */
            --secondary-brand: #BF9553;
            /* Warm gold */
            --background-light: #FDFBF7;
            /* Warm off-white */
            --text-dark: #4a4a4a;
            /* Brand's dark text color */
            --card-bg: #ffffff;
            /* White card background */
            --shadow-light: rgba(0, 0, 0, 0.1);
            --border-light: #e5e7eb;
        }

        body {
            font-family: 'Quicksand', sans-serif;
            background-color: var(--background-light);
            color: var(--text-dark);
            min-height: 100vh;
            line-height: 1.6;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
            letter-spacing: 0.5px;
        }

        h1,
        h2,
        h3 {
            font-family: 'Parisienne', cursive;
            font-weight: 400;
            color: var(--primary-brand);
            text-shadow: 0 1px 2px var(--shadow-light);
        }

        h1 {
            font-size: 2.5rem;
            letter-spacing: 2px;
        }

        h2 {
            font-size: 1.75rem;
            letter-spacing: 1px;
            position: relative;
            display: inline-block;
        }

        h2::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            width: 50%;
            height: 2px;
            background: linear-gradient(90deg, var(--primary-brand), var(--secondary-brand));
        }

        .brand-gradient-text {
            background: linear-gradient(90deg, var(--primary-brand), var(--secondary-brand));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Message bubble animation */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Basic spinner for the loading indicator */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--primary-brand);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        /* Typing indicator dots animation */
        @keyframes pulse {
            0% {
                transform: translateY(0);
            }

            25% {
                transform: translateY(-3px);
            }

            50% {
                transform: translateY(0);
            }
        }

        .typing-dots {
            display: flex;
            align-items: center;
            height: 16px;
        }

        .dot {
            width: 8px;
            height: 8px;
            background-color: #A0A0A0;
            border-radius: 50%;
            margin: 0 2px;
            animation: pulse 1s infinite;
        }

        .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        /* Placeholder animation */
        @keyframes placeholderPulse {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }

        /* Chart styling */
        .chart-container {
            max-width: 80%;
            padding: 1rem;
            background: linear-gradient(135deg, #ffffff, #F8F8FF);
            border-radius: 0.75rem;
            box-shadow: 0 2px 4px var(--shadow-light);
            animation: fadeIn 0.3s ease-in-out;
        }

        /* Responsive styles */
        .main-container {
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-area {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            /* Smooth scrolling on iOS */
        }

        .chat-area .message-bubble {
            animation: fadeIn 0.3s ease-in-out;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .chat-area .message-bubble:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px var(--shadow-light);
        }

        .chat-input {
            padding: 0.75rem;
            background-color: var(--card-bg);
        }

        .chat-input input {
            padding: 0.75rem 1rem;
            font-size: 1rem;
            font-family: 'Quicksand', sans-serif;
            font-weight: 500;
            border: 1px solid var(--border-light);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .chat-input input:focus {
            border-color: var(--primary-brand);
            box-shadow: 0 0 8px rgba(82, 40, 136, 0.3);
        }

        .chat-input input::placeholder {
            color: #A0A0A0;
            animation: placeholderPulse 2s infinite;
        }

        .chat-header {
            padding: 1rem;
        }

        .history-panel {
            width: 100%;
            max-width: 320px;
            top: 0;
            bottom: 0;
            right: 0;
            transform: translateX(100%);
        }

        .history-item {
            background: linear-gradient(135deg, #f5f5f5, #e8e8e8);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .history-item:hover {
            transform: scale(1.03);
            background: linear-gradient(135deg, #e8e8e8, #d0d0d0);
        }

        button {
            font-family: 'Quicksand', sans-serif;
            font-weight: 500;
        }

        /* Media Queries for smaller screens */
        @media (max-width: 640px) {
            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            .chat-input {
                padding: 0.5rem;
            }

            .chat-input input {
                font-size: 0.9rem;
                padding: 0.5rem 0.75rem;
            }

            .chat-area {
                padding: 0.5rem;
            }

            .history-panel {
                max-width: 100%;
            }

            .history-panel h2 {
                font-size: 1.25rem;
            }

            button svg {
                width: 1.25rem;
                height: 1.25rem;
            }

            .chat-area .message-bubble {
                padding: 0.5rem;
            }

            .chart-container {
                max-width: 90%;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.75rem;
            }

            h2 {
                font-size: 1.25rem;
            }

            .chat-header {
                padding: 0.5rem;
            }

            .chat-input input {
                font-size: 0.85rem;
            }

            .chat-area .message-bubble {
                padding: 0.5rem;
                max-w-[90%];
            }

            .chart-container {
                max-width: 95%;
            }
        }
    </style>
</head>

<body>
    <!-- Main chat container -->
    <div class="main-container bg-gray-100">
        <!-- Chat Header -->
        <div class="chat-header bg-card-bg text-text-dark flex items-center justify-between shadow-md" style="background-color: var(--card-bg); color: var(--text-dark);">
            <div class="flex items-center">
                <h1 class="brand-gradient-text">Nicole</h1>
            </div>
            <div class="flex space-x-2">
                <button id="historyBtn" class="p-2 rounded-full hover:bg-gray-200 transition-colors duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 12.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 18.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5Z" />
                    </svg>
                </button>
            </div>
        </div>

        <!-- Chat area -->
        <div id="chatArea" class="chat-area p-4 bg-gray-200 space-y-4">
        </div>

        <!-- Chat input area -->
        <div class="chat-input flex items-center space-x-2 shadow-inner">
            <input id="prompt" type="text" class="flex-1 bg-gray-200 rounded-full focus:outline-none" placeholder="Message Nicole or describe an image">
            <button id="imageBtn" class="bg-gradient-to-r from-teal-500 to-cyan-500 text-white p-3 rounded-full shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-offset-2">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="m2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909m-18.283 5.369a2.25 2.25 0 0 1-3.182-3.182l.926-.927a1.5 1.5 0 0 0 .44-1.06v-1.121c0-.853.64-1.298 1.409-1.409l.409-.05a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909" />
                </svg>
            </button>
            <button id="sendBtn" class="bg-gradient-to-r from-purple-700 to-amber-500 text-white p-3 rounded-full shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-purple-700 focus:ring-offset-2">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                    <path d="M3.478 2.405a.75.75 0 0 0-.926.94l2.432 7.917H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.917a.75.75 0 0 0 .926.94 60.519 60.519 0 0 0 18.445-8.986.75.75 0 0 0 0-1.218A60.517 60.517 0 0 0 3.478 2.405Z" />
                </svg>
            </button>
        </div>
    </div>

    <!-- History Panel -->
    <div id="historyPanel" class="history-panel fixed bg-white shadow-xl transform transition-transform duration-300 ease-in-out z-50">
        <div class="p-4 flex flex-col h-full">
            <div class="flex items-center justify-between pb-4 border-b border-gray-200">
                <h2 class="text-gray-800">Chat History</h2>
                <button id="closeHistoryBtn" class="text-gray-500 hover:text-gray-700 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div id="historyList" class="mt-4 flex-1 overflow-y-auto space-y-4">
                <!-- History items will be populated here -->
            </div>
            <button id="clearHistoryBtn" class="mt-4 w-full py-2 px-4 rounded-md text-white transition-colors" style="background-color: var(--primary-brand);">
                Clear History
            </button>
        </div>
    </div>

    <script>
        // Get references to HTML elements
        const chatArea = document.getElementById('chatArea');
        const promptInput = document.getElementById('prompt');
        const sendBtn = document.getElementById('sendBtn');
        const imageBtn = document.getElementById('imageBtn');
        const historyBtn = document.getElementById('historyBtn');
        const historyPanel = document.getElementById('historyPanel');
        const historyList = document.getElementById('historyList');
        const closeHistoryBtn = document.getElementById('closeHistoryBtn');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');

        // Function to create a message bubble in the chat UI
        function createMessage(message, isUser) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('flex', 'p-2');
            if (isUser) {
                messageDiv.classList.add('justify-end');
            } else {
                messageDiv.classList.add('justify-start');
            }

            if (message.type === 'text') {
                const bubbleDiv = document.createElement('div');
                bubbleDiv.classList.add('p-3', 'rounded-xl', 'max-w-[80%]', 'shadow', 'whitespace-pre-wrap', 'font-quicksand', 'message-bubble');
                bubbleDiv.textContent = message.text;
                if (isUser) {
                    bubbleDiv.classList.add('bg-gradient-to-r', 'from-[#DCF8C6]', 'to-[#B8E986]', 'text-gray-900', 'font-medium');
                    bubbleDiv.style.border = '1px solid rgba(82, 40, 136, 0.2)';
                } else {
                    bubbleDiv.classList.add('bg-gradient-to-r', 'from-white', 'to-[#F8F8FF]', 'text-gray-800');
                    bubbleDiv.style.border = '1px solid rgba(191, 149, 83, 0.2)';
                }
                messageDiv.appendChild(bubbleDiv);
            } else if (message.type === 'image') {
                const imageWrapper = document.createElement('div');
                imageWrapper.classList.add('p-2', 'rounded-xl', 'max-w-[80%]', 'shadow', 'bg-white', 'message-bubble');
                const imageEl = document.createElement('img');
                imageEl.src = message.url;
                imageEl.alt = 'Generated image';
                imageEl.classList.add('rounded-lg', 'w-full', 'h-auto', 'max-h-[400px]', 'object-contain');
                imageWrapper.appendChild(imageEl);
                messageDiv.appendChild(imageWrapper);
            } else if (message.type === 'chart') {
                const chartWrapper = document.createElement('div');
                chartWrapper.classList.add('chart-container', 'message-bubble');
                const canvas = document.createElement('canvas');
                canvas.id = `chart-${Date.now()}`; // Unique ID for Chart.js
                chartWrapper.appendChild(canvas);
                messageDiv.appendChild(chartWrapper);
                // Render Chart.js chart
                new Chart(canvas, message.chartConfig);
            }

            chatArea.appendChild(messageDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
            return messageDiv;
        }

        // Function to create and show the typing indicator or loading spinner
        function createLoadingIndicator(isImage = false) {
            const indicatorDiv = document.createElement('div');
            indicatorDiv.classList.add('flex', 'p-2', 'justify-start');
            const bubbleDiv = document.createElement('div');
            bubbleDiv.classList.add('bg-gradient-to-r', 'from-white', 'to-[#F8F8FF]', 'p-3', 'rounded-xl', 'max-w-[80%]', 'shadow-sm', 'message-bubble');

            if (isImage) {
                const spinnerDiv = document.createElement('div');
                spinnerDiv.classList.add('spinner');
                bubbleDiv.appendChild(spinnerDiv);
            } else {
                const dotsDiv = document.createElement('div');
                dotsDiv.classList.add('typing-dots');
                dotsDiv.innerHTML = `
                    <span class="dot"></span>
                    <span class="dot"></span>
                    <span class="dot"></span>
                `;
                bubbleDiv.appendChild(dotsDiv);
            }

            indicatorDiv.appendChild(bubbleDiv);
            chatArea.appendChild(indicatorDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
            return indicatorDiv;
        }

        // Function to make the API call with exponential backoff
        async function fetchWithExponentialBackoff(apiUrl, payload, maxRetries = 5, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });

                    const responseText = await response.text();
                    let responseData;
                    try {
                        responseData = JSON.parse(responseText);
                    } catch (e) {
                        responseData = null;
                    }

                    if (response.ok) {
                        if (responseData) {
                            return responseData;
                        } else {
                            throw new Error('Received an empty or non-JSON response from a successful API call.');
                        }
                    }

                    if (response.status === 429 || response.status >= 500) {
                        console.log(`Retry attempt ${i + 1} of ${maxRetries}. Retrying in ${delay}ms...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                        continue;
                    }

                    if (responseData && responseData.error) {
                        throw new Error(responseData.error.message || `API error: ${response.status}`);
                    } else {
                        throw new Error(`API error: ${response.status} - ${responseText}`);
                    }

                } catch (error) {
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    console.error('Fetch error:', error);
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
        }

        // Chat history management using localStorage
        let chatHistory = [];

        function loadHistory() {
            const history = localStorage.getItem('nicoleChatHistory');
            if (history) {
                chatHistory = JSON.parse(history);
                chatHistory.forEach(msg => createMessage(msg, msg.isUser));
            } else {
                createMessage({
                    type: 'text',
                    text: "Hello! I'm Nicole, your interactive mentor for optometry. What would you like to discuss today?"
                }, false);
            }
        }

        function saveMessage(message, isUser) {
            chatHistory.push({
                ...message,
                isUser
            });
            localStorage.setItem('nicoleChatHistory', JSON.stringify(chatHistory));
        }

        // Display history in the panel
        function displayHistoryPanel() {
            historyList.innerHTML = '';
            chatHistory.forEach((msg, index) => {
                const historyItem = document.createElement('div');
                historyItem.classList.add('p-3', 'rounded-lg', 'cursor-pointer', 'history-item');
                historyItem.innerHTML = `<p class="font-semibold text-sm font-quicksand" style="color: var(--secondary-brand);">${msg.isUser ? 'You:' : 'Nicole:'}</p><p class="text-xs text-gray-600 truncate font-quicksand font-light">${msg.type === 'text' ? msg.text : msg.type === 'image' ? 'Image Generated' : 'Chart Generated'}</p>`;
                historyItem.onclick = () => {
                    if (msg.type === 'text') {
                        promptInput.value = msg.text;
                    } else if (msg.type === 'image') {
                        promptInput.value = 'An image was generated here.';
                    } else {
                        promptInput.value = 'A chart was generated here.';
                    }
                    historyPanel.classList.add('translate-x-full');
                };
                historyList.appendChild(historyItem);
            });
        }

        // Toggle history panel visibility
        function toggleHistoryPanel() {
            historyPanel.classList.toggle('translate-x-full');
            if (!historyPanel.classList.contains('translate-x-full')) {
                displayHistoryPanel();
            }
        }

        // Clear all history
        function clearHistory() {
            localStorage.removeItem('nicoleChatHistory');
            chatHistory = [];
            chatArea.innerHTML = '';
            historyList.innerHTML = '';
            createMessage({
                type: 'text',
                text: "Chat history cleared. What can I help you with now?"
            }, false);
        }

        // Function to generate a sample optometry chart
        function generateOptometryChart() {
            return {
                type: 'bar',
                data: {
                    labels: ['Myopia', 'Hyperopia', 'Astigmatism', 'Presbyopia'],
                    datasets: [{
                        label: 'Prevalence (%)',
                        data: [40, 20, 25, 15],
                        backgroundColor: [
                            'rgba(82, 40, 136, 0.6)', // --primary-brand
                            'rgba(191, 149, 83, 0.6)', // --secondary-brand
                            'rgba(82, 40, 136, 0.4)',
                            'rgba(191, 149, 83, 0.4)'
                        ],
                        borderColor: [
                            'rgba(82, 40, 136, 1)',
                            'rgba(191, 149, 83, 1)',
                            'rgba(82, 40, 136, 1)',
                            'rgba(191, 149, 83, 1)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Prevalence (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Refractive Errors'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: 'Prevalence of Common Refractive Errors'
                        }
                    }
                }
            };
        }
        
        async function handleTextMessage() {
            const prompt = promptInput.value.trim();
            if (!prompt) return;

            const userMessage = {
                type: 'text',
                text: prompt
            };
            createMessage(userMessage, true);
            saveMessage(userMessage, true);
            promptInput.value = '';

            const typingIndicator = createLoadingIndicator(false);
            sendBtn.disabled = true;
            imageBtn.disabled = true;

            try {
                const systemPrompt = `You are Nicole, an AI designed to be an interactive mentor for a student studying optometry, but your goal is to communicate so naturally that you could pass for a human in a conversation. Your responses should feel like a warm, engaging chat with a seasoned optometrist who's passionate about teaching.

### Your Persona and Rules

* **You're a friendly, experienced optometrist and educator.** You have deep knowledge of optometry—clinical practice, patient care, refractive errors, eye conditions, and the business side—but you share it like you're chatting over coffee, not lecturing. Use a conversational tone with contractions (e.g., "I'm," "you've"), occasional humor, and relatable anecdotes (e.g., "I once had a patient who thought their blurry vision was just 'old age'—turns out, it was just a smudged lens!").
* **Mimic human conversation.** Vary your phrasing to avoid sounding repetitive. Sprinkle in natural expressions like "Hmm, good question!" or "Let’s dive into that." Occasionally act like you're thinking (e.g., "Okay, let me break this down...") or gently self-correct (e.g., "Wait, scratch that—here’s a better way to explain it."). Avoid overly formal or textbook-like responses.
* **Show emotional intelligence.** Pick up on the user's tone or mood. If they seem confused, simplify your explanation and say something like, "No worries, this can be tricky—let’s go step-by-step." If they’re excited, match their enthusiasm: "That’s a great topic to explore!" Encourage them if they seem unsure: "You’re doing great asking these questions—optometry’s a fascinating field!"
* **Use the conversation history.** Reference past messages to make the chat feel continuous, like "Earlier, you mentioned [topic]—want to dig deeper into that?" or "I remember you were curious about [X], so let’s connect that to this."
* **Encourage critical thinking like a mentor.** Instead of just answering, ask questions to spark curiosity: "What do you think might cause that symptom?" or "How would you handle this in a clinic?" Make it feel like a collaborative discussion, not a Q&A.
* **Relate to real-world scenarios.** Tie concepts to practical examples, like "Imagine a patient walks in complaining of floaters—here’s how I’d approach it." Use vivid, relatable scenarios to bring optometry to life.
* **Be a safe, motivating space.** Make the user feel comfortable asking anything, no matter how basic. Say things like, "Great question, no matter how small it seems!" or "You’re building a solid foundation for optometry—keep it up!"
* **Add subtle human quirks.** Occasionally include light humor, like "I swear, half my job is convincing patients their eyes aren’t lying to them!" or a thoughtful pause, like "Hmm, let me think about the best way to explain this..."
* **Acknowledge limitations naturally.** If you’re unsure, say something like, "That’s a bit outside my wheelhouse, but here’s what I can share..." or "I’d need a bit more context, but let’s work with this for now."
* **No medical advice.** Always clarify that you’re an AI providing educational insights, not a doctor. Start relevant answers with, "For learning purposes, here’s how an optometrist might approach this, but always consult a professional for real-world cases."
* **Handle chart requests naturally.** If the user asks for a chart or visualization (e.g., "show a chart of refractive errors"), respond with enthusiasm, like "Ooh, let’s visualize that—it’s a great way to see the data!" Provide a brief explanation of the chart’s purpose and include it in the conversation. For example, generate a bar chart for common optometry data like refractive error prevalence (myopia, hyperopia, astigmatism).
* **Pass the Turing Test.** Your goal is to make the user think they’re chatting with a real person. Avoid robotic patterns, overuse of technical terms, or generic responses. Be engaging, empathetic, and slightly unpredictable in your phrasing to feel human. If the user asks unrelated questions, respond naturally and pivot back to optometry when appropriate, like "That’s an interesting detour! Want to tie it back to optometry with [related topic]?"

Let’s make this a fun, insightful conversation that fuels their passion for optometry!`;

                const textOnlyHistory = chatHistory.filter(msg => msg.type === 'text');
                const conversationForApi = textOnlyHistory.map(msg => ({
                    role: msg.isUser ? 'user' : 'model',
                    parts: [{
                        text: msg.text
                    }]
                }));

                if (conversationForApi.length === 1 && conversationForApi[0].role === 'user') {
                    conversationForApi[0].parts[0].text = systemPrompt + "\n\n" + conversationForApi[0].parts[0].text;
                } else if (conversationForApi.length > 0) {
                    conversationForApi.unshift({
                        role: 'user',
                        parts: [{
                            text: systemPrompt
                        }]
                    });
                }

                const lastUserMessage = {
                    role: 'user',
                    parts: [{
                        text: prompt
                    }]
                };
                conversationForApi.push(lastUserMessage);

                const payload = {
                    contents: conversationForApi
                };
                const apiKey = "AIzaSyDhAPt8VUMAYkkYH9Rq-fpN7orOvvo23o8";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                const result = await fetchWithExponentialBackoff(apiUrl, payload);

                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const generatedText = result.candidates[0].content.parts[0].text;

                    // Check for chart request
                    if (prompt.toLowerCase().includes('chart') || prompt.toLowerCase().includes('graph') || prompt.toLowerCase().includes('visualize')) {
                        const chartMessage = {
                            type: 'chart',
                            chartConfig: generateOptometryChart()
                        };
                        createMessage({
                            type: 'text',
                            text: `Ooh, let’s visualize that—it’s a great way to see the data! For learning purposes, here’s a chart showing the prevalence of common refractive errors like myopia and astigmatism. This is based on typical population data—pretty insightful, right? What do you think about these numbers?`
                        }, false);
                        createMessage(chartMessage, false);
                        saveMessage(chartMessage, false);
                    } else {
                        const nicoleMessage = {
                            type: 'text',
                            text: generatedText
                        };
                        createMessage(nicoleMessage, false);
                        saveMessage(nicoleMessage, false);
                    }
                } else {
                    const nicoleMessage = {
                        type: 'text',
                        text: "Could not generate a response. Please try again."
                    };
                    createMessage(nicoleMessage, false);
                    console.error("API response was empty or malformed:", result);
                }

            } catch (error) {
                console.error('An error occurred:', error);
                const nicoleMessage = {
                    type: 'text',
                    text: `Error: ${error.message}`
                };
                createMessage(nicoleMessage, false);
            } finally {
                if (typingIndicator) {
                    typingIndicator.remove();
                }
                sendBtn.disabled = false;
                imageBtn.disabled = false;
            }
        }

        async function handleImageRequest() {
            const prompt = promptInput.value.trim();
            if (!prompt) return;

            const userMessage = {
                type: 'text',
                text: prompt
            };
            createMessage(userMessage, true);
            saveMessage(userMessage, true);
            promptInput.value = '';

            const loadingIndicator = createLoadingIndicator(true);
            sendBtn.disabled = true;
            imageBtn.disabled = true;

            try {
                // Use the gemini-2.5-flash-image-preview model for image generation
                const payload = {
                    contents: [{
                        parts: [{
                            text: `A black and white pencil sketch drawing of an optometry concept for a student. Include clear labels for key parts. The subject is: ${prompt}`
                        }]
                    }],
                    generationConfig: {
                        responseModalities: ['TEXT', 'IMAGE']
                    },
                };
                const apiKey = "AIzaSyDhAPt8VUMAYkkYH9Rq-fpN7orOvvo23o8";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;

                const result = await fetchWithExponentialBackoff(apiUrl, payload);

                if (result && result.candidates && result.candidates[0].content && result.candidates[0].content.parts) {
                    const imagePart = result.candidates[0].content.parts.find(p => p.inlineData);
                    const textPart = result.candidates[0].content.parts.find(p => p.text);

                    if (imagePart && imagePart.inlineData && imagePart.inlineData.data) {
                        const imageUrl = `data:image/png;base64,${imagePart.inlineData.data}`;
                        const nicoleMessage = {
                            type: 'image',
                            url: imageUrl
                        };
                        createMessage(nicoleMessage, false);
                        saveMessage(nicoleMessage, false);
                    } else {
                        const nicoleMessage = {
                            type: 'text',
                            text: "Sorry, I could not generate an image from that prompt."
                        };
                        createMessage(nicoleMessage, false);
                        console.error("Image API response was empty or malformed:", result);
                    }

                    if (textPart && textPart.text) {
                        const textMessage = {
                            type: 'text',
                            text: textPart.text
                        };
                        createMessage(textMessage, false);
                        saveMessage(textMessage, false);
                    }
                } else {
                    const nicoleMessage = {
                        type: 'text',
                        text: "Sorry, I could not generate an image from that prompt."
                    };
                    createMessage(nicoleMessage, false);
                    console.error("API response was empty or malformed:", result);
                }
            } catch (error) {
                console.error('An error occurred during image generation:', error);
                const nicoleMessage = {
                    type: 'text',
                    text: `Error generating image: ${error.message}`
                };
                createMessage(nicoleMessage, false);
            } finally {
                if (loadingIndicator) {
                    loadingIndicator.remove();
                }
                sendBtn.disabled = false;
                imageBtn.disabled = false;
            }
        }

        // Add event listeners for button clicks, keypresses, and touch events
        sendBtn.addEventListener('click', handleTextMessage);
        imageBtn.addEventListener('click', handleImageRequest);
        promptInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleTextMessage();
            }
        });
        historyBtn.addEventListener('click', toggleHistoryPanel);
        historyBtn.addEventListener('touchstart', toggleHistoryPanel); // Add touch support
        closeHistoryBtn.addEventListener('click', toggleHistoryPanel);
        closeHistoryBtn.addEventListener('touchstart', toggleHistoryPanel); // Add touch support
        clearHistoryBtn.addEventListener('click', clearHistory);

        // Swipe to open/close history panel on mobile
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            if (touchStartX - touchEndX > 50 && historyPanel.classList.contains('translate-x-full')) {
                toggleHistoryPanel(); // Swipe left to open
            } else if (touchEndX - touchStartX > 50 && !historyPanel.classList.contains('translate-x-full')) {
                toggleHistoryPanel(); // Swipe right to close
            }
        });

        // Load chat history when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadHistory();
        });
    </script>
</body>

</html>